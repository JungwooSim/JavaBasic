## 07. Ojbect-orientied Programming 2

### 상속(inheritance)

- 상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- 상속의 특징은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여한다.
- 상속을 받는다는 것은 조상 클래스를 확장(extend)한다는 의미로 해석할 수도 있으며, 이것이 상속에 사용되는 키워드가 'extends'인 이유이기도 하다.
    - 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
    - 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
- **전체 프로그램을 구성하는 클래스들을 면밀히 설계 분석하여, 클래스간의 상속관계를 적절히 맺어 주는 것이 객체지향 프로그래밍에서 가장 중요한 부분이다.**

<img src="/src/me/study/object_oriented_programming2/img/1.jpeg" width="500px;">

**클래스간의 관계 - 포함관계**

- 클래스 간의 포함관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

<img src="/src/me/study/object_oriented_programming2/img/2.jpeg" width="500px;">

**클래스간의 관계 결정하기**

- 클래스를 작성하는데 있어서 상속관계를 맺어 줄 것인지 포함관계를 맺어 줄 것인지 결정하는 것은 때때로 혼돈스러울 수 있다. **그럴 때는 'is -a'와 'has -a'를 넣어서 문장을 만들어보면 클래스 간의 관계가 명확해 진다.**
    - Cicle is a Point. (상속관계)
    - Cicle has a Point. (참조관계) ← 문장이 더 매끄럽고 옳다는것을 알 수 있다.

**단일 상속(single inheritance)**

- 자바에서는 오직 단일 상속만 허용한다.
    - 클래스 간의 관계가 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다는 점에서 다중상속보다 유리하다.

**Object Class - 모든 클래스의 조상**

- Object 클래스는 모든 클래스 상속계층도의 최상위에 있는 조상클래스 이다.

<img src="/src/me/study/object_oriented_programming2/img/3.jpeg" width="500px;">

### Overriding

- 조상 클래스로부터 **상속받은 메서드의 내용을 변경하는 것**을 오버라이딩이라고 한다.
- 오버라이딩은 메서드의 내용만을 새로 작성하는 것이므로 메서드의 선언부는 조상의 것과 완전히 일치해야 한다.
- 오버라이딩 조건
    - 조상클래스의 메서드와 이름, 매개변수, 반환타입 모두가 같아야 한다.

**오버로딩(overloading) vs. 오버라이딩(overriding)**

- 오버로딩 : 기존에 없는 새로운 메서드를 정의하는 것(new)
- 오버라이딩 : 상속받은 메서드의 내용을 변경하는 것(change, modify)

**super**

- 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수 이다.
- 멤버변수와 지역변수의 이름이 같을 때  this를 붙여서 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별할 수 있다.

**super() - 조상 클래스의 생성자**

- this()는 같은 클래스의 다른 생성자를 호출하는데 사용되지만, super()는 조상 클래스의 생성자를 호출하는데 사용된다.
- Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자, this() 또는 super()를 호출해야 한다. 그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫줄에 삽입한다.

### 제어자(Modifier)

- 클래스, 변수, 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여
- 종류는 크게 2가지로 나눌 수 있다.
    - 접근 제어자 : public, protected, default, private
    - 그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
- 제어자는 하나의 대상에 여러 제어자를 조합하여 사용할 수 있다. 하지만 접근 제어자는 한 번에 네가지중 한가지만 선택해서 사용할 수 있다.

**static - 클래스의, 공통적인**

- 인스턴스변수는 하나의 클래스로부터 생성되었더라도 각기 다른 값을 유지하지만, 클래스변수(static 멤버변수)는 인스턴스에 관계없이 같은 값을 갖는다. → 하나의 변수를 모든 인스턴스가 공유하기 때문
- **static이 붙은 멤버변수와 메서드, 그리고 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용할 수 있다.**
- **인스턴스 메서드와 static 메서드의 근본적인 차이는 메서드 내에서 인스턴스 메서드를 사용하는가의 여부에 있다.**

<img src="/src/me/study/object_oriented_programming2/img/4.jpeg" width="500px;">

- **인스턴스 멤버를 사용하지 않는 메서드는 static을 붙여서 static메서드로 선언하는 것을 고려해보도록 한다. 가능하다면 static 메서드로 하는 것이 인스턴스를 생성하지 않고도 호출이 가능해서 더 편리하고 속도도 더 빠르다.**

**final - 마지막의, 변경될 수 없는**

- 변수에 사용되면 값을 변경할 수 없는 상수가 된다.
메서드에 사용되면 오버라이딩을 할 수 없다.
클래스에 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.

<img src="/src/me/study/object_oriented_programming2/img/5.jpeg" width="500px;">

- 생성자를 이용한 final멤버 변수의 초기화
    - final 이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스 변수의 경우 생성자에서 초기화 되도록 할 수 있다.

**abstract - 추상의, 미완성의**

<img src="/src/me/study/object_oriented_programming2/img/6.jpeg" width="500px;">

- 추상 클래스는 아직 완성되지 않은 메서드가 존재하는 '미완성 설계도'이므로 **인스턴스를 생성할 수 없다.**

### 접근 제어자(access modifier)

- 멤버 또는 클래스에 사용되며, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.

<img src="/src/me/study/object_oriented_programming2/img/7.jpeg" width="500px;">

- public > protected > default > private

**접근 제어자를 이용한 캡슐화**

- 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다.
또 다른 이유는 클래스 내에서만 사용되는, 내부 작업을 위해서 임시로 사용되는 멤버변수나 부분작업을 처리하기 위한 메서드 등의 멤버들을 클래스 내부에 감추기 위해서이다.
    - 이것을 데이터 감추기(data hiding) 이라 하며, 객체지향개념의 캡슐화(encapsulation)에 해당하는 내용이다)

<img src="/src/me/study/object_oriented_programming2/img/8.jpeg" width="500px;">

- 만일 메서드 하나를 변경해야된다고 가정할 때, 이 메서드의 접근 제어자가 public 이라면 변경 후에 오류가 없는지 테스트해야되는 범위가 넓다. 그러나 접근 제어가자 default 라면 패키지 내부만 확인해 보면 되고, private 라면 클래스 하나만 살펴보면 된다. → 접근 제어자 하나가 때로는 상당한 차이를 만들어 낼 수 있다.

**생성자의 접근 제어자**

- 생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다. (보통 생성자의 접근 제어자는 클래스의 접근 제어자와 같지만, 다르게 지정할 수도 있다.)

### 제어자(modifier)의 조합

<img src="/src/me/study/object_oriented_programming2/img/9.jpeg" width="500px;">

- 제어자를 조합해서 사용할 때 주의해야 할 사항
    - 메서드에 static과 abstract 를 함께 사용할 수 없다.
        - static 는 몸통이 있는(완성된) 메서드에만 사용할 수 있기 때문이다.
    - 클래스에 abstract 와 final 을 동시에 사용할 수 없다.
        - 클래스에서 사용되는 final 은 클래스를 확장할 수 없다는 의미다.
        abstract 는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문이다.
    - abstract 메서드의 접근제어자가 private일 수 없다.
        - abstract 는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손클래스에서 접근할 수 없기 때문이다.
    - 메서드에 private 와 final 을 같이 사용할 필요는 없다.
        - 접근 제어자가 private 인 메서드는 오버라이딩 될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.

    
